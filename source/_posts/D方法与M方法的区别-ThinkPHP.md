---
title: D方法与M方法的区别_ThinkPHP
date: 2017-05-02 17:27:36
tags: ThinkPHP
categories: 原创
---

在ThinkPHP中，可以无需进行任何模型定义。只有在需要封装单独的业务逻辑的时候，模型类才是必须被定义的。

D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化系统的`\Think\Model`基类，同时对于已实例化过的模型，不会重复实例化。

D方法实例化模型类的时候通常是实例化某个具体的模型类，如果仅仅是对数据表进行基本的CURD操作的话，使用M方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。

<!--more-->

### D方法实例化

D方法的参数就是模型的名称，并且和模型类的大小写定义是一致的，例如：

|参数|描述|
|:---:|:---:|
|模型名|模型的名称::和数据表前缀一起配合用于自动识别数据表名称|
|数据表前缀|当前数据表前缀::和模型名一起配合用于自动识别数据表名称|
|数据库连接信息|当前数据表的数据库连接信息::如果没有则获取配置文件中的|

> 如果在Linux环境下面，一定要注意D方法实例化的时候的模型名称的大小写。

D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复实例化。

```php
D方法还可以支持跨模块调用，需要使用：
//实例化Admin模块的User模型
D('Admin/User');
//实例化Extend扩展命名空间下的Info模型
D('Extend://Editor/Info');
```
    
**D方法实例化模型类的时候通常是实例化某个具体的模型类。**

D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复实例化。

> 注意：跨模块实例化模型类的时候 不支持自动加载公共模块的模型类。

### M方法实例化模型

M方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。

M方法也可以支持跨库操作，例如：

```php

// 使用M方法实例化 操作db_name数据库的ot_user表
$User = M('db_name.User','ot_');
// 执行其他的数据操作
$User->select();

```

M方法的参数和\Think\Model类的参数是一样的，也就是说，也可以这样实例化：
```php
$New  = M('new','think_',$connection);
// 等效于
$New = new \Think\Model('new','think_',$connection);

```

具体的参数含义可以参考前面的介绍。

M方法实例化的时候，默认情况下是直接实例化系统的\Think\Model类，如果希望实例化其他的公共模型类的话，可以使用如下方法：
```php
$User = M('\Home\Model\CommonModel:User','think_','db_config');
// 相当于 
$User = new \Home\Model\CommonModel('User','think_','db_config');
```

> 如果模型类有自己的业务逻辑，M方法是无法支持的，就算是已经定义了具体的模型类，M方法实例化的时候是会直接忽略。

### 区别与联系

1.  D方法实例化模型类的时候通常是实例化某个具体的模型类，如果仅仅是对数据表进行基本的CURD操作的话，使用M方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。
2.  D方法包含M方法。

<div class="text-right"> [ThinkPHP3.2.3模型实例化](http://www.kancloud.cn/manual/thinkphp/1729) </div>